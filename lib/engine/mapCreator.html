<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Poke-Editor v3.6 - Spawn Points</title>
    <style>
        body { display: flex; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #1a1a1a; color: white; margin: 0; height: 100vh; overflow: hidden; }
        
        /* Toolbar Ã  gauche */
        #toolbar { width: 300px; min-width: 300px; background: #2c3e50; padding: 15px; display: flex; flex-direction: column; gap: 8px; border-right: 2px solid #34495e; overflow-y: auto; }
        
        /* Viewport au centre */
        #viewport { 
            flex-grow: 1; 
            position: relative; 
            overflow: hidden; 
            background: #111; 
            display: flex; 
            flex-direction: column; /* AjoutÃ© */
            align-items: center; 
            justify-content: center; 
        }     

        /* Inspecteur Ã  droite */
        #inspector { width: 320px; min-width: 320px; background: #2c3e50; padding: 15px; border-left: 2px solid #34495e; overflow-y: auto;  /* MasquÃ© par dÃ©faut */ }

        canvas { box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        
        /* Style des cartes de dialogue */
        .diag-row { background: #34495e; padding: 10px; border-radius: 6px; border-left: 4px solid #3498db; display: flex; flex-direction: column; gap: 8px; position: relative; }
        .diag-row textarea { background: #1a1a1a; color: #fff; border: 1px solid #555; border-radius: 4px; padding: 5px; font-family: inherit; resize: none; }
        .diag-header { display: flex; justify-content: space-between; align-items: center; font-size: 0.8em; font-weight: bold; color: #3498db; }
        
        /* UI Elements */
        .btn { background: #3498db; border: none; color: white; padding: 8px 12px; cursor: pointer; border-radius: 4px; font-weight: bold; transition: 0.2s; }
        .btn:hover { background: #2980b9; transform: translateY(-1px); }
        .btn-green { background: #27ae60; }
        .btn-red { background: #e74c3c; padding: 2px 6px; font-size: 0.8em; }
        .active-mode { background: #e74c3c !important; box-shadow: inset 0 0 10px rgba(0,0,0,0.3); }
        
        .input-group { display: flex; align-items: center; justify-content: space-between; font-size: 0.85em; margin-bottom: 4px; }
        input, select { background: #1a1a1a; border: 1px solid #555; color: white; padding: 5px; border-radius: 4px; }
        
        hr { border: 0; border-top: 1px solid #444; margin: 10px 0; }
    </style>
</head>
<body>

<div id="toolbar">
    <h3>Configuration</h3>
    <div class="input-group">Largeur: <input type="number" id="map-w" value="20"></div>
    <div class="input-group">Hauteur: <input type="number" id="map-h" value="20"></div>
    <button class="btn btn-green" style="margin-top:0" onclick="resizeMap()">Appliquer / Reset</button>
    
    <hr>
    <h3>Chargement</h3>
    <div class="input-group">Map: &nbsp; <input type="file" id="upload-map-txt" accept=".txt" style="width: 170px;"></div>
    <div class="input-group">Collisions: &nbsp; <input type="file" id="upload-collision-txt" accept=".txt" style="width: 170px;"></div>
    <div class="input-group">EntitÃ©s: &nbsp; <input type="file" id="upload-entities-txt" accept=".txt" style="width: 170px;"></div>
    <div class="input-group">Dialogues: <input type="file" id="upload-dialogues-txt" accept=".txt" style="width: 170px;"></div>
    <button class="btn" style="margin-top: 5px" onclick="loadAllFiles()">ðŸ“‚ Charger Pack</button>
    <hr>
    
    <hr>
    <h3>Tileset</h3>
    <input type="file" id="upload-tileset" accept="image/*">
    <div class="input-group">Tile Size: <input type="number" id="tile-size" value="32"></div>
    <div id="tileset-container">
        <canvas id="tileset-canvas"></canvas>
    </div>

    <hr>
    <h3>Outils</h3>
    <button class="btn" id="btn-draw" onclick="setMode('draw')">ðŸŽ¨ Dessin</button>
    <button class="btn" id="btn-coll" onclick="setMode('collision')">ðŸš« Collision (-1)</button>
    <button class="btn" id="btn-spaw" onclick="setMode('spawn')">ðŸš© Spawn Point (-2)</button>
    <button class="btn" id="btn-trans" onclick="setMode('transition')">ðŸšª Transition (ID)</button>
    <button class="btn" id="btn-antitrans" onclick="setMode('antitransition')"> ðŸš© Anti-Transition (spawnpointID) </button>
    
    <div id="transition-settings1" style="display:none; background: #1e2b38; padding: 10px; border-radius: 5px; border: 1px solid #9b59b6;">
        <div class="input-group">ID Zone Cible: <input type="number" id="target-zone-id" value="1" min="1"></div>
    </div>
    <div id="transition-settings2" style="display:none; background: #1e2b38; padding: 20px; border-radius: 5px; border: 1px solid #9b59b6;">
        <div class="input-group">SpawnpointID Cible: <input type="number" id="target-porte-id" value="1" min="1"></div>
    </div>

    <div id="antitransition-settings" style="display:none; background: #1e2b38; padding: 10px; border-radius: 5px; border: 1px solid #9b59b6;">
        <div class="input-group"> spawnpointID: <input type="number" id="source-porte-id" value="1" min="1"></div>
    </div>

    <button class="btn" id="btn-enti" onclick="setMode('entities')">ðŸ‘¤ EntitÃ©s (NPC/OBJ)</button>

    <hr>
    <button class="btn btn-green" onclick="exportFiles()">ðŸ’¾ Exporter .txt</button>
    <div class="info">
        <span class="highlight">Gid :</span> Poser l'Ã©lÃ©ment<br>
        <span class="highlight">Droit :</span> Effacer (0)<br>
        <span class="highlight">Note :</span> Le Spawn Point (-2) dÃ©finit oÃ¹ le joueur arrive dans cette zone.
    </div>
</div>

<div id="viewport">
    <canvas id="map-canvas"></canvas>
</div>

<div id="inspector">
    <h3 style="color: #f1c40f; margin-top: 0;">Inspecteur</h3>
    
    <div id="entity-settings">
        <div class="input-group">Type: <select id="ent-type"><option value="NPC">NPC</option><option value="OBJ">OBJET</option></select></div>
        <div class="input-group">Nom: <input type="text" id="ent-name" value="Pierre" style="width:120px;"></div>
        <div class="input-group">Sprite ID: <input type="number" id="ent-sprite" value="0"></div>
        <div class="input-group">Orientation: <select id="ent-orien"><option value="DOWN">Bas</option><option value="UP">Haut</option><option value="LEFT">Gauche</option><option value="RIGHT">Droite</option></select></div>
        <div class="input-group">Diag Key: <input type="text" id="ent-diag" value="DIAG_1" style="width:120px;"></div>
        
        <hr>
        
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <h4 style="margin: 0; color: #3498db;">Dialogues</h4>
            <button class="btn" onclick="addDialogueRow()" style="padding: 2px 8px; background: #27ae60;">+</button>
        </div>

        <div id="dialogue-list" style="margin-top: 10px; display: flex; flex-direction: column; gap: 10px;">
            </div>
        
        <p style="font-size: 0.7em; color: #bdc3c7; margin-top: 15px;">
            Note: La clÃ© de dialogue doit correspondre au fichier dialogues.txt lors de l'export.
        </p>
    </div>
</div>

<script>
    let tileSize = 32;
    let mapW = 20;
    let mapH = 20;
    let mode = 'draw';
    let selectedTile = 0;
    
    let mapData = [];
    let collisionData = []; 
    let entities = []; // Liste d'objets {type, name, sprite, x, y, orien, diagKey}
    let dialogues = {}; // Objet { diagKey: [ {text, type, action}, ... ] }

    let scale = 1.0;
    let viewX = 0;
    let viewY = 0;
    let isPanning = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    
    const mapCanvas = document.getElementById('map-canvas');
    const viewport = document.getElementById('viewport');
    const ctx = mapCanvas.getContext('2d');
    const tsCanvas = document.getElementById('tileset-canvas');
    const tsCtx = tsCanvas.getContext('2d');
    let tilesetImg = new Image();

    document.querySelectorAll('#entity-settings input, #entity-settings select').forEach(input => {
        input.addEventListener('input', () => {
            if (selectedEntity) {
                selectedEntity.type = document.getElementById('ent-type').value;
                selectedEntity.name = document.getElementById('ent-name').value;
                selectedEntity.sprite = parseInt(document.getElementById('ent-sprite').value);
                selectedEntity.orien = document.getElementById('ent-orien').value;
                selectedEntity.diagKey = document.getElementById('ent-diag').value;
                drawMap();
                renderDialogueList(); // Important si on change la Diag Key
            }
        });
    });

    function resizeCanvas() {
        mapCanvas.width = viewport.clientWidth;
        mapCanvas.height = viewport.clientHeight;
        if (mapData.length > 0) drawMap();
    }

    async function loadAllFiles() {
        const mapFile = document.getElementById('upload-map-txt').files[0];
        const collFile = document.getElementById('upload-collision-txt').files[0];
        const entFile = document.getElementById('upload-entities-txt').files[0];
        const diagFile = document.getElementById('upload-dialogues-txt').files[0];

        if (!mapFile || !collFile) {
            alert("Au minimum, sÃ©lectionnez map.txt et collisionMap.txt");
            return;
        }

        try {
            // Chargement Map et Collisions
            const mapText = await mapFile.text();
            const collText = await collFile.text();
            parseAndLoadMap(mapText, collText);

            // Chargement EntitÃ©s (optionnel)
            if (entFile) {
                const entText = await entFile.text();
                parseEntities(entText);
            }

            // Chargement Dialogues (optionnel)
            if (diagFile) {
                const diagText = await diagFile.text();
                parseDialogues(diagText);
            }

            drawMap();
            alert("Pack chargÃ© avec succÃ¨s !");
        } catch (e) {
            console.error(e);
            alert("Erreur lors du chargement des fichiers.");
        }
    }

    function parseAndLoadMap(mapContent, collisionContent) {
        try {
            tileSize = parseInt(document.getElementById('tile-size').value) || 32;

            // On nettoie les espaces et on sÃ©pare par ligne, en ignorant les lignes vides
            const mapRows = mapContent.trim().split(/\r?\n/).filter(line => line.trim());
            const collisionRows = collisionContent.trim().split(/\r?\n/).filter(line => line.trim());

            // Extraction de la largeur (basÃ©e sur la premiÃ¨re ligne)
            const newMapW = mapRows[0].split(',').filter(cell => cell.trim() !== "").length;
            const newMapH = mapRows.length;

            // Transformation en tableau de nombres pur (on nettoie chaque cellule)
            const newMapData = mapRows.join(',').split(',')
                                .filter(cell => cell.trim() !== "")
                                .map(num => parseInt(num.trim()));

            const newCollisionData = collisionRows.join(',').split(',')
                                        .filter(cell => cell.trim() !== "")
                                        .map(num => parseFloat(num.trim())); // Float pour gÃ©rer tes anciens IDs si besoin

            // VÃ©rification de sÃ©curitÃ©
            if (newMapData.length !== (newMapW * newMapH)) {
                throw new Error(`Taille map incohÃ©rente : attendu ${newMapW * newMapH}, reÃ§u ${newMapData.length}`);
            }

            if (newMapData.length !== newCollisionData.length) {
                alert(`Erreur de synchronisation : Map (${newMapData.length} cases) vs Collisions (${newCollisionData.length} cases)`);
                return;
            }

            // Assignation
            mapW = newMapW;
            mapH = newMapH;
            mapData = newMapData;
            collisionData = newCollisionData;

            document.getElementById('map-w').value = mapW;
            document.getElementById('map-h').value = mapH;
            
            scale = 1.0;
            viewX = (viewport.clientWidth - mapW * tileSize) / 2;
            viewY = (viewport.clientHeight - mapH * tileSize) / 2;
            
            if (tilesetImg.complete && tilesetImg.src) {
                tsCanvas.width = tilesetImg.width;
                tsCanvas.height = tilesetImg.height;
                drawTileset();
            }
            
            drawMap();
            alert("Map chargÃ©e avec succÃ¨s !");

        } catch (e) {
            console.error("DÃ©tails de l'erreur :", e);
            alert("Erreur lors du parsing : " + e.message);
        }
    }

    function initData() {
        mapData = Array(mapW * mapH).fill(0);
        collisionData = Array(mapW * mapH).fill(0);
        
        scale = 1.0;
        viewX = (viewport.clientWidth - mapW * tileSize) / 2;
        viewY = (viewport.clientHeight - mapH * tileSize) / 2;

        drawMap();
    }

    function resizeMap() {
        if(!confirm("Reset complet de la map ?")) return;
        mapW = parseInt(document.getElementById('map-w').value);
        mapH = parseInt(document.getElementById('map-h').value);
        tileSize = parseInt(document.getElementById('tile-size').value);
        initData();
    }

    function drawTileset() {
        if (!tilesetImg.complete || !tilesetImg.src) return;
        
        tsCtx.clearRect(0, 0, tsCanvas.width, tsCanvas.height);
        tsCtx.drawImage(tilesetImg, 0, 0);
        
        // Highlight the selected tile
        const tsCols = Math.floor(tilesetImg.width / tileSize);
        const sx = (selectedTile % tsCols) * tileSize;
        const sy = Math.floor(selectedTile / tsCols) * tileSize;
        
        tsCtx.strokeStyle = '#f1c40f'; // bright yellow
        tsCtx.lineWidth = 2;
        tsCtx.strokeRect(sx + 1, sy + 1, tileSize - 2, tileSize - 2);
    }

    document.getElementById('upload-tileset').onchange = (e) => {
        const reader = new FileReader();
        reader.onload = (event) => {
            tilesetImg.src = event.target.result;
            tilesetImg.onload = () => {
                tsCanvas.width = tilesetImg.width;
                tsCanvas.height = tilesetImg.height;
                drawTileset();
                drawMap();
            };
        };
        reader.readAsDataURL(e.target.files[0]);
    };

    function setMode(m) {
        mode = m;
        // Update boutons
        document.querySelectorAll('.btn').forEach(b => b.classList.remove('active-mode'));
        const currentBtn = document.getElementById('btn-' + m.substring(0,4));
        if(currentBtn) currentBtn.classList.add('active-mode');

        // Affichage des rÃ©glages Ã  gauche
        document.getElementById('transition-settings1').style.display = (m === 'transition') ? 'block' : 'none';
        document.getElementById('transition-settings2').style.display = (m === 'transition') ? 'block' : 'none';
        document.getElementById('antitransition-settings').style.display = (m === 'antitransition') ? 'block' : 'none';

        // Affichage de l'INSPECTEUR Ã  droite
        const inspector = document.getElementById('inspector');
        if (m === 'entities') {
            inspector.style.display = 'block';
        } else {
            inspector.style.display = 'none';
        }
        
        // Recalculer la taille du canvas car les barres latÃ©rales ont pu changer
        resizeCanvas(); 
    }


    tsCanvas.onclick = (e) => {
        if (!tilesetImg.complete || !tilesetImg.src) return;
        const x = Math.floor(e.offsetX / tileSize);
        const y = Math.floor(e.offsetY / tileSize);
        const cols = Math.floor(tilesetImg.width / tileSize);
        selectedTile = y * cols + x;
        drawTileset();
        setMode('draw');
    };

    const handleInput = (e) => {
        if (isPanning) return;
        if (e.buttons !== 1 && e.buttons !== 2) return; // Only left/right click

        const rect = viewport.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // Convert screen coords to world coords
        const worldX = (mouseX - viewX) / scale;
        const worldY = (mouseY - viewY) / scale;

        const x = Math.floor(worldX / tileSize);
        const y = Math.floor(worldY / tileSize);
        
        if (x >= 0 && x < mapW && y >= 0 && y < mapH) {
            const index = y * mapW + x;
            
            if (e.buttons === 2) { // Right click
                if (mode === 'draw') mapData[index] = 0;
                else collisionData[index] = 0;
            } else { // Left click
                if (mode === 'draw') {
                    mapData[index] = selectedTile;
                } 
                else if (mode === 'collision') {
                    collisionData[index] = -1;
                } 
                else if (mode === 'spawn') {
                    const oldSpawnIndex = collisionData.indexOf(-2);
                    if (oldSpawnIndex !== -1) {
                        collisionData[oldSpawnIndex] = 0;
                    }
                    collisionData[index] = -2;
                }
                else if (mode === 'transition') {
                    if (collisionData[index] > 0) {
                        const existingZoneId = collisionData[index] >> 16;
                        const existingPorteId = collisionData[index] & 0xFFFF;
                        document.getElementById('target-zone-id').value = existingZoneId;
                        document.getElementById('target-porte-id').value = existingPorteId;
                    }
                    collisionData[index] = (parseInt(document.getElementById('target-zone-id').value) << 16) | parseInt(document.getElementById('target-porte-id').value);
                }
                else if (mode === 'antitransition') {
                    const oldSpawnIndex = collisionData.indexOf(document.getElementById('source-porte-id').value * (-1)- 100);
                    if (oldSpawnIndex !== -1) {
                        collisionData[oldSpawnIndex] = 0;
                    }
                    if (collisionData[index] < -100) {
                        document.getElementById('source-porte-id').value = -collisionData[index];
                    }
                    const spawnpointID = parseInt(document.getElementById('source-porte-id').value) || 1;
                    collisionData[index] = -100 - spawnpointID;
                }
                else if (mode === 'entities') {
                    // Chercher si une entitÃ© existe dÃ©jÃ  Ã  cet endroit
                    const found = entities.find(e => e.x === x && e.y === y);

                    if (found) {
                        // SÃ©lectionner l'entitÃ© existante
                        selectedEntity = found;
                        // Remplir les champs de l'inspecteur
                        document.getElementById('ent-type').value = found.type;
                        document.getElementById('ent-name').value = found.name;
                        document.getElementById('ent-sprite').value = found.sprite;
                        document.getElementById('ent-orien').value = found.orien;
                        document.getElementById('ent-diag').value = found.diagKey;
                    } else {
                        // CrÃ©er une nouvelle entitÃ©
                        const newEnt = {
                            type: document.getElementById('ent-type').value,
                            name: document.getElementById('ent-name').value,
                            sprite: parseInt(document.getElementById('ent-sprite').value),
                            x: x,
                            y: y,
                            orien: document.getElementById('ent-orien').value,
                            diagKey: document.getElementById('ent-diag').value
                        };
                        entities.push(newEnt);
                        selectedEntity = newEnt;
                    }
                    renderDialogueList(); // RafraÃ®chir la liste des dialogues
                }
            }
            drawMap();
        }
    };

    viewport.addEventListener('mousedown', handleInput);
    viewport.addEventListener('mousemove', handleInput);
    viewport.addEventListener('contextmenu', (e) => e.preventDefault());

    // --- Pan and Zoom ---
    viewport.addEventListener('wheel', (e) => {
        e.preventDefault();
        const zoomIntensity = 0.1;
        const delta = -Math.sign(e.deltaY);
        const oldScale = scale;

        const rect = viewport.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        scale += delta * zoomIntensity * scale;
        scale = Math.max(0.2, Math.min(scale, 4)); // Clamp scale

        // Adjust view transformation to zoom towards the mouse
        viewX = mouseX - (mouseX - viewX) * (scale / oldScale);
        viewY = mouseY - (mouseY - viewY) * (scale / oldScale);

        drawMap();
    }, { passive: false }); // passive:false is important for preventDefault

    viewport.addEventListener('mousedown', (e) => {
        if (e.button === 1) { // Middle mouse button
            isPanning = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            viewport.style.cursor = 'grabbing';
            e.preventDefault();
        }
    });

    window.addEventListener('mousemove', (e) => {
        if (isPanning) {
            const dx = e.clientX - lastMouseX;
            const dy = e.clientY - lastMouseY;
            viewX += dx;
            viewY += dy;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            drawMap();
        }
    });

    window.addEventListener('mouseup', (e) => {
        if (e.button === 1 && isPanning) {
            isPanning = false;
            viewport.style.cursor = 'crosshair';
        }
    });
    // --- End Pan and Zoom ---

    function drawMap() {
        ctx.fillStyle = "#1a1a1a";
        ctx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);

        ctx.save();
        ctx.translate(viewX, viewY);
        ctx.scale(scale, scale);

        const tsCols = Math.floor(tilesetImg.width / tileSize);

        for(let i = 0; i < mapData.length; i++) {
            const tx = i % mapW;
            const ty = Math.floor(i / mapW);
            
            if(tilesetImg.complete && tilesetImg.src) {
                const tileIdx = mapData[i];
                const sx = (tileIdx % tsCols) * tileSize;
                const sy = Math.floor(tileIdx / tsCols) * tileSize;
                ctx.drawImage(tilesetImg, sx, sy, tileSize, tileSize, tx*tileSize, ty*tileSize, tileSize, tileSize);
            }

            let val = collisionData[i];
            
            // RENDU DES CALQUES
            if(val === -1) { // Collision
                ctx.fillStyle = "rgba(231, 76, 60, 0.6)"; 
                ctx.fillRect(tx*tileSize, ty*tileSize, tileSize, tileSize);
                ctx.strokeStyle = "White";
                ctx.strokeRect(tx*tileSize, ty*tileSize, tileSize, tileSize);
            }
            // =======================
            // SPAWN POINT SIMPLE
            // =======================
            else if (val === -2) {

                const x = tx * tileSize;
                const y = ty * tileSize;

                // Fond vert
                ctx.fillStyle = "rgba(46, 204, 113, 0.6)";
                ctx.fillRect(x, y, tileSize, tileSize);

                // Drapeau
                const flagX = x + tileSize / 2;
                const flagY = y + tileSize / 2 + 6;

                ctx.textAlign = "center";
                ctx.font = "20px Arial";
                ctx.shadowColor = "black";
                ctx.shadowBlur = 3;
                ctx.fillStyle = "rgba(255,255,255,0.6)";

                ctx.fillText("ðŸš©", flagX, flagY);
            }


            // =======================
            // ANTI-TRANSITION
            // =======================
            else if (val <= -100) {

                const x = tx * tileSize;
                const y = ty * tileSize;

                // Fond vert
                ctx.fillStyle = "rgba(46, 204, 113, 0.6)";
                ctx.fillRect(x, y, tileSize, tileSize);

                // Drapeau
                const flagX = x + tileSize / 2;
                const flagY = y + tileSize / 2 + 6;

                ctx.textAlign = "center";
                ctx.font = "20px Arial";
                ctx.shadowColor = "black";
                ctx.shadowBlur = 3;
                ctx.fillStyle = "rgba(255,255,255,0.6)";

                ctx.fillText("ðŸš©", flagX, flagY);

                // ID en dessous
                let spawnpointID = (100 + val) * (-1);

                ctx.shadowBlur = 0;
                ctx.font = "bold 11px Arial";

                ctx.fillText(
                    spawnpointID,
                    flagX + 3,
                    flagY + 7
                );
            }



            else if(val > 0) { // Transition
                const x = tx * tileSize;
                const y = ty * tileSize;

                ctx.fillStyle = "rgba(155, 89, 182, 0.7)"; 
                ctx.fillRect(x, y, tileSize, tileSize);
                ctx.fillStyle = "white";
                ctx.font = "bold 14px Segoe UI";
                ctx.textAlign = "center";
                ctx.shadowColor = "black";
                ctx.shadowBlur = 4;

                const targetZoneId = val >> 16;
                const spawnPointId = val & 0xFFFF;

                ctx.fillText(targetZoneId, tx*tileSize + tileSize/2, ty*tileSize + tileSize/2 + 2);
                ctx.shadowBlur = 4;
                ctx.font = "bold 8px Arial";

                ctx.fillText(
                    spawnPointId,
                    x + tileSize / 2,
                    y + tileSize / 2 + 10
                );
            }
        }
        
        // Draw grid over the entire map
        const mapPixelWidth = mapW * tileSize;
        const mapPixelHeight = mapH * tileSize;
        ctx.strokeStyle = "rgba(255,255,255,0.05)";
        for(let x=0; x<=mapPixelWidth; x+=tileSize) {
            ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,mapPixelHeight); ctx.stroke();
        }
        for(let y=0; y<=mapPixelHeight; y+=tileSize) {
            ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(mapPixelWidth,y); ctx.stroke();
        }
        
        // Draw a border around the map boundaries
        ctx.strokeStyle = "#555";
        ctx.lineWidth = 2 / scale; // Keep border width consistent on zoom
        ctx.strokeRect(0, 0, mapPixelWidth, mapPixelHeight);

        // --- Rendu des EntitÃ©s ---
        entities.forEach(ent => {
            const ex = ent.x * tileSize;
            const ey = ent.y * tileSize;
            ctx.fillStyle = ent.type === "NPC" ? "#f1c40f" : "#e67e22"; // Jaune pour NPC, Orange pour OBJ
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.arc(ex + tileSize/2, ey + tileSize/2, tileSize/3, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
            ctx.fillStyle = "white";
            ctx.font = "10px Arial";
            ctx.fillText(ent.name, ex + tileSize/2, ey + 10);
        });

        ctx.restore();
    }

    function formatDataWithNewlines(data, width) {
        let result = "";
        for (let i = 0; i < data.length; i++) {
            result += data[i];
            if ((i + 1) % width === 0) result += "\n";
            else result += ",";
        }
        return result.trim();
    }

    function parseEntities(content) {
        entities = content.split('\n').filter(line => line.trim() && !line.startsWith('#')).map(line => {
            const [type, name, sprite, x, y, orien, diagKey] = line.split('|');
            return { type, name, sprite, x: parseInt(x), y: parseInt(y), orien, diagKey };
        });
    }

    function parseDialogues(content) {
        dialogues = {};
        let currentKey = null;
        
        content.split('\n').forEach(line => {
            line = line.trim();
            if (!line || line.startsWith('#')) return;

            if (line.startsWith('[') && line.endsWith(']')) {
                currentKey = line.substring(1, line.length - 1);
                dialogues[currentKey] = [];
            } else if (currentKey) {
                const parts = line.split('|');
                
                if (parts.length >= 1) {
                    // On utilise .replace() sans le ^ et on ajoute .trim() Ã  la fin
                    const text = parts[0] ? parts[0].replace(/S:\s*/i, "").trim() : "";
                    const type = parts[1] ? parts[1].replace(/T:\s*/i, "").trim() : "Classic";
                    const action = parts[2] ? parts[2].replace(/A:\s*/i, "").trim() : "NONE";

                    console.log(`Parsed: Text="${text}", Type="${type}", Action="${action}"`);

                    dialogues[currentKey].push({
                        text: text,
                        type: type,
                        action: action
                    });
                }
            }
        });
    }

    // Ajoute une nouvelle ligne de dialogue vide
    function addDialogueRow() {
        const key = document.getElementById('ent-diag').value;
        
        if (!key) {
            alert("Indiquez une Diag Key d'abord");
            return;
        }

        if (!dialogues[key]) {
            dialogues[key] = [];
        }

        dialogues[key].push({ 
            text: "Nouveau dialogue", 
            type: "Classic", 
            action: "NONE" 
        });
        
        renderDialogueList();
    }

    // Affiche la liste des dialogues pour la clÃ© actuelle
    function renderDialogueList() {
        const list = document.getElementById('dialogue-list');
        list.innerHTML = "";
        const key = document.getElementById('ent-diag').value;
        const currentDialogues = dialogues[key] || [];

        currentDialogues.forEach((diag, index) => {
            const row = document.createElement('div');
            row.className = 'diag-row';
            row.innerHTML = `
                <div class="diag-header">
                    <span>DIALOGUE #${index + 1}</span>
                    <button class="btn btn-red" onclick="removeDiag(${index})">Suppr.</button>
                </div>
                <textarea rows="2" oninput="updateDiag(${index}, 'text', this.value)" placeholder="Texte...">${diag.text}</textarea>
                <div class="input-group">
                    Type: 
                    <select onchange="updateDiag(${index}, 'type', this.value)">
                        <option value="Classic" ${diag.type === 'Classic' ? 'selected' : ''}>Classic</option>
                        <option value="Object" ${diag.type === 'Object' ? 'selected' : ''}>Object</option>
                    </select>
                </div>
                <div class="input-group">
                    Action: <input type="text" value="${diag.action}" oninput="updateDiag(${index}, 'action', this.value)" placeholder="HEAL, GIVE...">
                </div>
            `;
            list.appendChild(row);
        });
    }

    // Mise Ã  jour des donnÃ©es en temps rÃ©el
    function updateDiag(index, field, value) {
        const key = document.getElementById('ent-diag').value;
        dialogues[key][index][field] = value;
    }

    function removeDiag(index) {
        const key = document.getElementById('ent-diag').value;
        dialogues[key].splice(index, 1);
        renderDialogueList();
    }

    function moveDiag(index, direction) {
        const key = document.getElementById('ent-diag').value;
        const target = index + direction;
        if (target < 0 || target >= dialogues[key].length) return;
        
        const temp = dialogues[key][index];
        dialogues[key][index] = dialogues[key][target];
        dialogues[key][target] = temp;
        renderDialogueList();
    }

    function exportFiles() {
        const formattedMap = formatDataWithNewlines(mapData, mapW);
        const formattedColl = formatDataWithNewlines(collisionData, mapW);
        
        // Formatage Entities
        const formattedEnt = entities.map(e => 
            `${e.type}|${e.name}|${e.sprite}|${e.x}|${e.y}|${e.orien}|${e.diagKey}`
        ).join('\n');

        // Formatage Dialogues
        let formattedDiag = "";
        for (let key in dialogues) {
            formattedDiag += `[${key}]\n`;
            dialogues[key].forEach(d => {
                // Format: texte|type|action
                formattedDiag += `S: ${d.text} | T: ${d.type}| A: ${d.action}\n`;
            });
            formattedDiag += `\n`;
        }

        download("map.txt", formattedMap);
        download("collisionMap.txt", formattedColl);
        download("entities.txt", formattedEnt);
        download("dialogues.txt", formattedDiag);
    }

    function download(filename, text) {
        let element = document.createElement('a');
        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
        element.setAttribute('download', filename);
        element.style.display = 'none';
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
    }

    initData();
    setMode('draw');
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
</script>

</body>
</html>