<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Poke-Editor v3.6 - Spawn Points</title>
    <style>
        body { display: flex; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #1a1a1a; color: white; margin: 0; height: 100vh; overflow: hidden; }
        
        /* Toolbar √† gauche */
        #toolbar { width: 300px; min-width: 300px; background: #2c3e50; padding: 15px; display: flex; flex-direction: column; gap: 8px; border-right: 2px solid #34495e; overflow-y: auto; }
        
        /* Viewport au centre */
        #viewport { 
            flex-grow: 1; 
            position: relative; 
            overflow: hidden; 
            background: #111; 
            display: flex; 
            flex-direction: column; /* Ajout√© */
            align-items: center; 
            justify-content: center; 
        }     

        /* Inspecteur √† droite */
        #inspector { width: 320px; min-width: 320px; background: #2c3e50; padding: 15px; border-left: 2px solid #34495e; overflow-y: auto;  /* Masqu√© par d√©faut */ }

        canvas { box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        
        /* Style des cartes de dialogue */
        .diag-row { background: #34495e; padding: 10px; border-radius: 6px; border-left: 4px solid #3498db; display: flex; flex-direction: column; gap: 8px; position: relative; }
        .diag-row textarea { background: #1a1a1a; color: #fff; border: 1px solid #555; border-radius: 4px; padding: 5px; font-family: inherit; resize: none; }
        .diag-header { display: flex; justify-content: space-between; align-items: center; font-size: 0.8em; font-weight: bold; color: #3498db; }
        
        /* UI Elements */
        .btn { background: #3498db; border: none; color: white; padding: 8px 12px; cursor: pointer; border-radius: 4px; font-weight: bold; transition: 0.2s; }
        .btn:hover { background: #2980b9; transform: translateY(-1px); }
        .btn-green { background: #27ae60; }
        .btn-red { background: #e74c3c; padding: 2px 6px; font-size: 0.8em; }
        .active-mode { background: #e74c3c !important; box-shadow: inset 0 0 10px rgba(0,0,0,0.3); }
        
        .input-group { display: flex; align-items: center; justify-content: space-between; font-size: 0.85em; margin-bottom: 4px; }
        input, select { background: #1a1a1a; border: 1px solid #555; color: white; padding: 5px; border-radius: 4px; }
        
        hr { border: 0; border-top: 1px solid #444; margin: 10px 0; }
    </style>
</head>
<body>

<div id="toolbar">
    <h3>Configuration</h3>
    <div class="input-group">Largeur: <input type="number" id="map-w" value="20"></div>
    <div class="input-group">Hauteur: <input type="number" id="map-h" value="20"></div>
    <button class="btn btn-green" style="margin-top:0" onclick="resizeMap()">Appliquer / Reset</button>
    
    <hr>
    <h3>Chargement</h3>
    <div class="input-group">Map: &nbsp; <input type="file" id="upload-map-txt" accept=".txt" style="width: 170px;"></div>
    <div class="input-group">Collisions: &nbsp; <input type="file" id="upload-collision-txt" accept=".txt" style="width: 170px;"></div>
    <div class="input-group">Entit√©s: &nbsp; <input type="file" id="upload-entities-txt" accept=".txt" style="width: 170px;"></div>
    <div class="input-group">Dialogues: <input type="file" id="upload-dialogues-txt" accept=".txt" style="width: 170px;"></div>
    <button class="btn" style="margin-top: 5px" onclick="loadAllFiles()">üìÇ Charger Pack</button>
    <hr>
    
    <hr>
    <h3>Tileset</h3>
    <input type="file" id="upload-tileset" accept="image/*">
    <div class="input-group">Tile Size: <input type="number" id="tile-size" value="32"></div>
    <div id="tileset-container">
        <canvas id="tileset-canvas"></canvas>
    </div>

    <hr>
    <h3>Outils</h3>
    <button class="btn" id="btn-draw" onclick="setMode('draw')">üé® Dessin</button>
    <button class="btn" id="btn-empty" onclick="setMode('empty')">üßπ Vide </button>
    <button class="btn" id="btn-wall" onclick="setMode('wall')">üß± Mur (100+)</button>
    <button class="btn" id="btn-sidewall" onclick="setMode('sidewall')">üìê Mur C√¥t√© (200+)</button>
    <button class="btn" id="btn-sideRightwall" onclick="setMode('siderightwall')">‚ï∫ Mur C√¥t√© Droit (300+)</button>
    <button class="btn" id="btn-coll" onclick="setMode('collision')">üö´ Collision (-1)</button>
    <button class="btn" id="btn-spaw" onclick="setMode('spawn')">üö© Spawn Point (-2)</button>
    <button class="btn" id="btn-trans" onclick="setMode('transition')">üö™ Transition (ID)</button>
    <button class="btn" id="btn-antitrans" onclick="setMode('antitransition')"> üö© Anti-Transition (spawnpointID) </button>
    
    <div id="transition-settings1" style="display:none; background: #1e2b38; padding: 10px; border-radius: 5px; border: 1px solid #9b59b6;">
        <div class="input-group">ID Zone Cible: <input type="number" id="target-zone-id" value="1" min="1"></div>
    </div>
    <div id="transition-settings2" style="display:none; background: #1e2b38; padding: 20px; border-radius: 5px; border: 1px solid #9b59b6;">
        <div class="input-group">SpawnpointID Cible: <input type="number" id="target-porte-id" value="1" min="1"></div>
    </div>

    <div id="antitransition-settings" style="display:none; background: #1e2b38; padding: 10px; border-radius: 5px; border: 1px solid #9b59b6;">
        <div class="input-group"> spawnpointID: <input type="number" id="source-porte-id" value="1" min="1"></div>
    </div>

    <button class="btn" id="btn-enti" onclick="setMode('entities')">üë§ Entit√©s (NPC/OBJ/IOG)</button>

    <hr>
    <button class="btn btn-green" onclick="exportFiles()">üíæ Exporter .txt</button>
    <div class="info">
        <span class="highlight">Gid :</span> Poser l'√©l√©ment<br>
        <span class="highlight">Droit :</span> Effacer (0)<br>
        <span class="highlight">Note :</span> Le Spawn Point (-2) d√©finit o√π le joueur arrive dans cette zone.
    </div>
</div>

<div id="viewport">
    <canvas id="map-canvas"></canvas>
</div>

<div id="inspector">
    <h3 style="color: #f1c40f; margin-top: 0;">Inspecteur</h3>
    
    <div id="entity-settings">
        <div class="input-group">Type: <select id="ent-type" onchange="updateInspectorUI(this.value)"><option value="NPC">NPC</option><option value="OBJ">OBJET</option><option value="IOG">IOG</option></select></div>
        <div class="input-group" id="ent-name-group"><span id="ent-name-label">Nom:</span> <input type="text" id="ent-name" value="Pierre" style="width:120px;"></div>
        <div class="input-group" id="ent-size-group" style="display:none;">Taille (LxH): <input type="number" id="ent-w" value="1" style="width:40px;" min="1"> x <input type="number" id="ent-h" value="1" style="width:40px;" min="1"></div>
        <div class="input-group" id="ent-sprite-group">Sprite name: <input type="text" id="ent-sprite" value="gabou.png"></div>
        <div class="input-group" id="ent-orien-group">Orientation: <select id="ent-orien"><option value="DOWN">Bas</option><option value="UP">Haut</option><option value="LEFT">Gauche</option><option value="RIGHT">Droite</option></select></div>
        <div class="input-group" id="ent-move-group">Type Deplacement Initial: <select id="ent-move" onchange="updateInspectorMove(this.value)"><option value="NONE">Aucun</option><option value = "RANDOM">Random</option><option value="SIMPLE">Simple</option><option value="PINGPONG">Ping Pong</option><option value="LOOP">Boucle</option></select></div>
        <div class="input-group" id="ent-dest-group">Destination(s): <input type="text" id="ent-dest" placeholder="{5,2};{8,2}">
        </div>
        <div id="dialogues-section">
            <div class="input-group" id="ent-diag-group">Diag Key: <input type="text" id="ent-diag" value="DIAG_1" style="width:120px;"></div>
            <div class="input-group" style="margin-top:5px; border-top:1px solid #444; padding-top:5px;"><span style="color:#f1c40f; font-size:0.9em;">√âdition en cours:</span> <input type="text" id="editing-diag-key" style="width:100px; border:none; background:transparent; color:#f1c40f; font-weight:bold;" onchange="switchEditingKey(this.value)"></div>
            <hr>
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <h4 style="margin: 0; color: #3498db;">Dialogues</h4>
                <button class="btn" onclick="addDialogueRow()" style="padding: 2px 8px; background: #27ae60;">+</button>
            </div>

            <div id="dialogue-list" style="margin-top: 10px; display: flex; flex-direction: column; gap: 10px;">
                </div>
            
            <p style="font-size: 0.7em; color: #bdc3c7; margin-top: 15px;">
                Note: La cl√© de dialogue doit correspondre au fichier dialogues.txt lors de l'export.
            </>
        </div>
    </div>
</div>

<script>
    let tileSize = 32;
    let mapW = 20;
    let mapH = 20;
    
    let offsetX = 0;
    let offsetX2 = 0;
    let offsetY = 0;
    let mode = 'draw';
    let selectedTile = 0;
    
    let mapData = [];
    let wallData = [];
    let playableIndexes = [];
    let collisionData = []; 
    let entities = []; // Liste d'objets {type, name, sprite, x, y, orien, diagKey}
    let dialogues = {}; // Objet { diagKey: [ {text, type, action}, ... ] }
    let editingDiagKey = "";

    let scale = 1.0;
    let viewX = 0;
    let viewY = 0;
    let isPanning = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let interiorWidth = 0;
    let selectedEntity = null;
    let isDraggingEntity = false;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    
    const mapCanvas = document.getElementById('map-canvas');
    const viewport = document.getElementById('viewport');
    const ctx = mapCanvas.getContext('2d');
    const tsCanvas = document.getElementById('tileset-canvas');
    const tsCtx = tsCanvas.getContext('2d');
    let tilesetImg = new Image();

    document.querySelectorAll('#entity-settings input, #entity-settings select').forEach(input => {
        input.addEventListener('input', () => {
            if (selectedEntity) {
                selectedEntity.type = document.getElementById('ent-type').value;
                selectedEntity.name = document.getElementById('ent-name').value;
                selectedEntity.sizeX = parseInt(document.getElementById('ent-w').value) || 1;
                selectedEntity.sizeY = parseInt(document.getElementById('ent-h').value) || 1;
                selectedEntity.sprite = document.getElementById('ent-sprite').value;
                selectedEntity.orien = document.getElementById('ent-orien').value;
                selectedEntity.diagKey = document.getElementById('ent-diag').value;
                selectedEntity.actionType = document.getElementById('ent-move').value;
                selectedEntity.destination = document.getElementById('ent-dest').value;
                
                if (input.id === 'ent-diag') {
                    editingDiagKey = selectedEntity.diagKey;
                    document.getElementById('editing-diag-key').value = editingDiagKey;
                }

                drawMap();
                renderDialogueList(); // Important si on change la Diag Key
            }
        });
    });

    function resizeCanvas() {
        mapCanvas.width = viewport.clientWidth;
        mapCanvas.height = viewport.clientHeight;
        if (mapData.length > 0) drawMap();
    }

    async function loadAllFiles() {
        const mapFile = document.getElementById('upload-map-txt').files[0];
        const collFile = document.getElementById('upload-collision-txt').files[0];
        const entFile = document.getElementById('upload-entities-txt').files[0];
        const diagFile = document.getElementById('upload-dialogues-txt').files[0];

        if (!mapFile || !collFile) {
            alert("Au minimum, s√©lectionnez map.txt et collisionMap.txt");
            return;
        }

        try {
            // Chargement Map et Collisions
            const mapText = await mapFile.text();
            const collText = await collFile.text();
            parseAndLoadMap(mapText, collText);

            // Chargement Entit√©s (optionnel)
            if (entFile) {
                const entText = await entFile.text();
                parseEntities(entText, mapText);
            }

            // Chargement Dialogues (optionnel)
            if (diagFile) {
                const diagText = await diagFile.text();
                parseDialogues(diagText);
            }

            drawMap();
            alert("Pack charg√© avec succ√®s !");
        } catch (e) {
            console.error(e);
            alert("Erreur lors du chargement des fichiers.");
        }
    }

    function parseAndLoadMap(mapContent, collisionContent) {
        try {

            tileSize = parseInt(document.getElementById('tile-size').value) || 32;

            // On nettoie les espaces et on s√©pare par ligne, en ignorant les lignes vides
            const mapRows = mapContent.trim().split(/\r?\n/).filter(line => line.trim());
            const collisionRows = collisionContent.trim().split(/\r?\n/).filter(line => line.trim());

            // Extraction de la largeur (bas√©e sur la premi√®re ligne)
            const newMapW = mapRows[0].split(',').filter(cell => cell.trim() !== "").length;
            const newMapH = mapRows.length;

            // Transformation en tableau de nombres pur
            const rawMapData = mapRows.join(',').split(',')
                                .filter(cell => cell.trim() !== "")
                                .map(num => parseInt(num.trim()));
            
            // S√©paration Sol / Murs
            const newMapData = [];
            const newWallData = [];
            const rawMapDataLength = rawMapData.length;
            playableIndexes = [];

            interiorWidth = mapRows[0]
                .split(',')
                .map(v => parseInt(v))
                .filter(v => v >= 0 && v < 100).length;



            for (let i = 0; i < rawMapDataLength; i++) {
                const v = rawMapData[i];
                if (v >= 0 && v < 100) {
                    playableIndexes.push(i);
                }
            }


            for (let val of rawMapData) {
                let baseWall = 0;
                if (val >= 200 && val < 300) {
                    // Mur C√¥t√© (stock√© comme 1000 + ID dans l'√©diteur pour diff√©rencier)
                    baseWall = val - 200;
                    newWallData.push(1000 + baseWall);
                    newMapData.push(0);
                } else if (val >= 100 && val < 200) {
                      
                    baseWall = val - 100;
                    newWallData.push(val - 100);
                    newMapData.push(0); // Sol par d√©faut
                }else if (val >= 300) {
                    // Mur C√¥t√© Droit (stock√© comme 2000 + ID dans l'√©diteur pour diff√©rencier)
                    baseWall = val - 300;
                    newWallData.push(2000 + baseWall);
                    newMapData.push(0); // Sol par d√©faut
                } else {
                    newWallData.push(-1);
                    newMapData.push(val);
                }
            }

            let loadedCollisions = collisionRows.join(',')
            .split(',')
            .filter(c => c.trim() !== "")
            .map(n => parseFloat(n.trim()));

            const newCollisionData = Array(newMapData.length).fill(0);

            // Projection uniquement sur les cases jouables
            for (let i = 0; i < loadedCollisions.length && i < playableIndexes.length; i++) {
                newCollisionData[playableIndexes[i]] = loadedCollisions[i];
            }


            // V√©rification de s√©curit√©
            if (newMapData.length !== (newMapW * newMapH)) {
                throw new Error(`Taille map incoh√©rente : attendu ${newMapW * newMapH}, re√ßu ${newMapData.length}`);
            }

            if (newMapData.length !== newCollisionData.length) {
                alert(`Erreur de synchronisation : Map (${newMapData.length} cases) vs Collisions (${newCollisionData.length} cases)`);
                return;
            }

            // Assignation
            mapW = newMapW;
            mapH = newMapH;
            mapData = newMapData;
            wallData = newWallData;
            collisionData = newCollisionData;

            for (let r = 0; r < mapH; r++) {
                let isFullWallRow = true;
                if (wallData[r * mapW] === -1) { // -1 signifie que c'est du sol (mapData)
                        offsetY++;
                } else {
                    break;
                }
            }

            for (let c = 0; c < mapW; c++) {
                if (wallData[c] === -1) {
                    offsetX++;
                } else {
                    break;
                }
            }

            for (let c = mapW - 1; c >= 0; c--) {
                if (wallData[c] === -1) {
                    offsetX2++;
                } else {
                    break;
                }
            }

            document.getElementById('map-w').value = mapW;
            document.getElementById('map-h').value = mapH;
            
            scale = 1.0;
            viewX = (viewport.clientWidth - mapW * tileSize) / 2;
            viewY = (viewport.clientHeight - mapH * tileSize) / 2;
            
            if (tilesetImg.complete && tilesetImg.src) {
                tsCanvas.width = tilesetImg.width;
                tsCanvas.height = tilesetImg.height;
                drawTileset();
            }
            
            drawMap();
            alert("Map charg√©e avec succ√®s !");

        } catch (e) {
            console.error("D√©tails de l'erreur :", e);
            alert("Erreur lors du parsing : " + e.message);
        }
    }

    function initData() {
        mapData = Array(mapW * mapH).fill(0);
        wallData = Array(mapW * mapH).fill(-1);
        collisionData = Array(mapW * mapH).fill(0);
        
        scale = 1.0;
        viewX = (viewport.clientWidth - mapW * tileSize) / 2;
        viewY = (viewport.clientHeight - mapH * tileSize) / 2;

        drawMap();
    }

    function resizeMap() {
        if(!confirm("Reset complet de la map ?")) return;
        mapW = parseInt(document.getElementById('map-w').value);
        mapH = parseInt(document.getElementById('map-h').value);
        tileSize = parseInt(document.getElementById('tile-size').value);
        initData();
    }
    function mapIndexToPlayable(index) {
        return playableIndexes.indexOf(index);
    }

    function playableToMapIndex(pIndex) {
        return playableIndexes[pIndex];
    }

    function drawTileset() {
        if (!tilesetImg.complete || !tilesetImg.src) return;
        
        tsCtx.clearRect(0, 0, tsCanvas.width, tsCanvas.height);
        tsCtx.drawImage(tilesetImg, 0, 0);
        
        // Highlight the selected tile
        const tsCols = Math.floor(tilesetImg.width / tileSize);
        const sx = (selectedTile % tsCols) * tileSize;
        const sy = Math.floor(selectedTile / tsCols) * tileSize;
        
        tsCtx.strokeStyle = '#f1c40f'; // bright yellow
        tsCtx.lineWidth = 2;
        tsCtx.strokeRect(sx + 1, sy + 1, tileSize - 2, tileSize - 2);
    }

    document.getElementById('upload-tileset').onchange = (e) => {
        const reader = new FileReader();
        reader.onload = (event) => {
            tilesetImg.src = event.target.result;
            tilesetImg.onload = () => {
                tsCanvas.width = tilesetImg.width;
                tsCanvas.height = tilesetImg.height;
                drawTileset();
                drawMap();
            };
        };
        reader.readAsDataURL(e.target.files[0]);
    };

    function setMode(m) {
        mode = m;
        // Update boutons
        document.querySelectorAll('.btn').forEach(b => b.classList.remove('active-mode'));
        const modeToBtn = {
            draw: "btn-draw",
            empty: "btn-empty",
            wall: "btn-wall",
            sidewall: "btn-sidewall",
            siderightwall: "btn-sideRightwall",
            collision: "btn-coll",
            spawn: "btn-spaw",
            transition: "btn-trans",
            antitransition: "btn-antitrans",
            entities: "btn-enti"
        };

        const currentBtn = document.getElementById(modeToBtn[m]);
        if (currentBtn) currentBtn.classList.add("active-mode");

        // Affichage des r√©glages √† gauche
        document.getElementById('transition-settings1').style.display = (m === 'transition') ? 'block' : 'none';
        document.getElementById('transition-settings2').style.display = (m === 'transition') ? 'block' : 'none';
        document.getElementById('antitransition-settings').style.display = (m === 'antitransition') ? 'block' : 'none';

        // Affichage de l'INSPECTEUR √† droite
        const inspector = document.getElementById('inspector');
        if (m === 'entities') {
            inspector.style.display = 'block';
        } else {
            inspector.style.display = 'none';
        }
        
        // Recalculer la taille du canvas car les barres lat√©rales ont pu changer
        resizeCanvas(); 
    }


    tsCanvas.onclick = (e) => {
        if (!tilesetImg.complete || !tilesetImg.src) return;
        const x = Math.floor(e.offsetX / tileSize);
        const y = Math.floor(e.offsetY / tileSize);
        const cols = Math.floor(tilesetImg.width / tileSize);
        selectedTile = y * cols + x;
        drawTileset();
        setMode('draw');
    };

    const handleInput = (e) => {
        if (isPanning || e.altKey) return;
        if (e.buttons !== 1 && e.buttons !== 2) return; // Only left/right click

        const rect = viewport.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // Convert screen coords to world coords
        const worldX = (mouseX - viewX) / scale;
        const worldY = (mouseY - viewY) / scale;

        const x = Math.floor(worldX / tileSize);
        const y = Math.floor(worldY / tileSize);
        
        if (x >= 0 && x < mapW && y >= 0 && y < mapH) {
            const index = y * mapW + x;
            // === SUPPRESSION ENTIT√â AU CLIC DROIT ===
            if (e.buttons === 2 && mode === 'entities') {
                const entIndex = entities.findIndex(ent => {
                    const w = ent.sizeX || 1;
                    const h = ent.sizeY || 1;
                    return x >= ent.x && x < ent.x + w && y >= ent.y && y < ent.y + h;
                });

                if (entIndex !== -1) {
                    // Supprimer
                    entities.splice(entIndex, 1);

                    // Si c'√©tait celle s√©lectionn√©e
                    if (selectedEntity && selectedEntity.x === x && selectedEntity.y === y) {
                        selectedEntity = null;
                        document.getElementById('dialogue-list').innerHTML = "";
                    }
                    collisionDate[index] = 0;

                    drawMap();
                    return;
                }
            }

            if (e.buttons === 2) { // Right click
                if (mode === 'draw') mapData[index] = 0;
                else if (mode === 'wall' || mode === 'sidewall' || mode === 'siderightwall') wallData[index] = -1;
                else collisionData[index] = 0;
            } else { // Left click
                if (mode === 'draw') {
                    mapData[index] = selectedTile; 
                } 
                else if (mode === 'empty') {
                    mapData[index] = -1;
                    wallData[index] = -1;
                }
                else if (mode === 'wall') {
                    wallData[index] = selectedTile;
                }
                else if (mode === 'sidewall') {
                    wallData[index] = 1000 + selectedTile; // 1000+ pour diff√©rencier visuellement
                }
                 else if (mode === 'siderightwall') {
                    wallData[index] = 2000 + selectedTile; // 2000+ pour diff√©rencier visuellement
                }
                else if (mode === 'collision') {
                    collisionData[index] = -1;
                } 
                else if (mode === 'spawn') {
                    const oldSpawnIndex = collisionData.indexOf(-2);
                    if (oldSpawnIndex !== -1) {
                        collisionData[oldSpawnIndex] = 0;
                    }
                    collisionData[index] = -2;
                }
                else if (mode === 'transition') {
                    if (collisionData[index] > 0) {
                        const existingZoneId = collisionData[index] >> 16;
                        const existingPorteId = collisionData[index] & 0xFFFF;
                        document.getElementById('target-zone-id').value = existingZoneId;
                        document.getElementById('target-porte-id').value = existingPorteId;
                    }
                    collisionData[index] = (parseInt(document.getElementById('target-zone-id').value) << 16) | parseInt(document.getElementById('target-porte-id').value);
                }
                else if (mode === 'antitransition') {
                    const oldSpawnIndex = collisionData.indexOf(document.getElementById('source-porte-id').value * (-1)- 100);
                    if (oldSpawnIndex !== -1) {
                        collisionData[oldSpawnIndex] = 0;
                    }
                    if (collisionData[index] < -100) {
                        document.getElementById('source-porte-id').value = -collisionData[index];
                    }
                    const spawnpointID = parseInt(document.getElementById('source-porte-id').value) || 1;
                    collisionData[index] = -100 - spawnpointID;
                }
                else if (mode === 'entities') {
                    if (isDraggingEntity && selectedEntity) {
                        selectedEntity.x = x - dragOffsetX;
                        selectedEntity.y = y - dragOffsetY;
                    } else {
                        // Chercher si une entit√© existe d√©j√† √† cet endroit
                        const found = entities.find(e => {
                            const w = e.sizeX || 1;
                            const h = e.sizeY || 1;
                            return x >= e.x && x < e.x + w && y >= e.y && y < e.y + h;
                        });

                        if (found) {
                            // S√©lectionner l'entit√© existante
                            selectedEntity = found;
                            
                            if (e.type === 'mousedown') {
                                isDraggingEntity = true;
                                dragOffsetX = x - found.x;
                                dragOffsetY = y - found.y;
                            }

                            // Remplir les champs de l'inspecteur
                            document.getElementById('ent-type').value = found.type;
                            document.getElementById('ent-name').value = found.name;
                            document.getElementById('ent-w').value = found.sizeX || 1;
                            document.getElementById('ent-h').value = found.sizeY || 1;
                            document.getElementById('ent-sprite').value = found.sprite;
                            document.getElementById('ent-orien').value = found.orien;
                            document.getElementById('ent-diag').value = found.diagKey;
                            document.getElementById('ent-move').value = found.actionType;
                            document.getElementById('ent-dest').value = found.destinations || "";
                            editingDiagKey = found.diagKey;
                            document.getElementById('editing-diag-key').value = editingDiagKey;

                        } else {
                            if (document.getElementById('ent-type').value === 'IOG') collisionData[index] = 0;
                            // Cr√©er une nouvelle entit√©
                            const mapIndex = y * mapW + x;
                            const playableIndex = mapIndexToPlayable(mapIndex);

                            if (playableIndex === -1) {
                                alert("Impossible de placer une entit√© sur un mur");
                                return;
                            }

                            const pX = playableIndex % interiorWidth;
                            const pY = Math.floor(playableIndex / interiorWidth);
                            const newEnt = {
                                type: document.getElementById('ent-type').value,
                                name: document.getElementById('ent-name').value,
                                sprite: document.getElementById('ent-sprite').value,
                                sizeX: parseInt(document.getElementById('ent-w').value) || 1,
                                sizeY: parseInt(document.getElementById('ent-h').value) || 1,
                                x: pX,
                                y: pY,
                                orien: document.getElementById('ent-orien').value,
                                diagKey: document.getElementById('ent-diag').value,
                                actionType: document.getElementById('ent-move').value,
                                destination : ""
                            };
                            entities.push(newEnt);
                            selectedEntity = newEnt;
                            if (e.type === 'mousedown') {
                                isDraggingEntity = true;
                                dragOffsetX = 0;
                                dragOffsetY = 0;
                            }
                            editingDiagKey = newEnt.diagKey;
                            document.getElementById('editing-diag-key').value = editingDiagKey;
                        }
                        
                        updateInspectorUI(selectedEntity.type);
                        updateInspectorMove(selectedEntity.actionType);
                        renderDialogueList(); // Rafra√Æchir la liste des dialogues
                    }
                }
            }
            drawMap();
        }
    };

    viewport.addEventListener('mousedown', handleInput);
    viewport.addEventListener('mousemove', handleInput);
    viewport.addEventListener('contextmenu', (e) => e.preventDefault());

    // --- Pan and Zoom (ALT + Drag) ---

    viewport.addEventListener('wheel', (e) => {
        e.preventDefault();
        const zoomIntensity = 0.1;
        const delta = -Math.sign(e.deltaY);
        const oldScale = scale;

        const rect = viewport.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        scale += delta * zoomIntensity * scale;
        scale = Math.max(0.2, Math.min(scale, 4));

        viewX = mouseX - (mouseX - viewX) * (scale / oldScale);
        viewY = mouseY - (mouseY - viewY) * (scale / oldScale);

        drawMap();
    }, { passive: false });

    viewport.addEventListener("mousedown", (e) => {
        if (e.button === 0 && e.altKey) {
            isPanning = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            viewport.style.cursor = "grabbing";
            e.preventDefault();
        }
    });

    window.addEventListener("mousemove", (e) => {
        if (!isPanning) return;

        const dx = e.clientX - lastMouseX;
        const dy = e.clientY - lastMouseY;

        viewX += dx;
        viewY += dy;

        lastMouseX = e.clientX;
        lastMouseY = e.clientY;

        drawMap();
    });

    window.addEventListener("mouseup", () => {
        if (isPanning) {
            isPanning = false;
            viewport.style.cursor = "crosshair";
        }
        isDraggingEntity = false;
    });

    // --- End Pan and Zoom ---


    function drawMap() {
        ctx.fillStyle = "#1a1a1a";
        ctx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);

        ctx.save();
        ctx.translate(viewX, viewY);
        ctx.scale(scale, scale);

        const tsCols = Math.floor(tilesetImg.width / tileSize);

        for(let i = 0; i < mapData.length; i++) {
            const tx = i % mapW;
            const ty = Math.floor(i / mapW);
            
            if(tilesetImg.complete && tilesetImg.src) {
                const tileIdx = mapData[i];
                const sx = (tileIdx % tsCols) * tileSize;
                const sy = Math.floor(tileIdx / tsCols) * tileSize;

                
                ctx.drawImage(tilesetImg, sx, sy, tileSize, tileSize, tx*tileSize, ty*tileSize, tileSize, tileSize);
            }

            // RENDU DES MURS
            const wallIdx = wallData[i];
            if (wallIdx >= 0 && tilesetImg.complete && tilesetImg.src) {
                let realTile = wallIdx;
                let strokeColor = "rgba(52, 152, 219, 0.8)"; // Bleu par d√©faut (100+)

                if (wallIdx >= 2000) {
                    realTile = wallIdx - 2000;
                    strokeColor = "rgba(100, 126, 34, 0.8)"; // Vert (300+)
                } else if (wallIdx >= 1000) {
                    realTile = wallIdx - 1000;
                    strokeColor = "rgba(230, 126, 34, 0.8)"; // Orange (200+)
                }

                const sx = (realTile % tsCols) * tileSize;
                const sy = Math.floor(realTile / tsCols) * tileSize;
    
                // Dessiner la texture r√©elle du tileset
                ctx.drawImage(tilesetImg, sx, sy, tileSize, tileSize, tx * tileSize, ty * tileSize, tileSize, tileSize);

                // Dessiner le contour de couleur pour l'√©diteur
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 2;
                ctx.strokeRect(tx * tileSize, ty * tileSize, tileSize, tileSize);
            }

            let val = collisionData[i];
            
            // RENDU DES CALQUES
            if(val === -1) { // Collision
                ctx.fillStyle = "rgba(231, 76, 60, 0.6)"; 
                ctx.fillRect(tx*tileSize, ty*tileSize, tileSize, tileSize);
                ctx.strokeStyle = "White";
                ctx.strokeRect(tx*tileSize, ty*tileSize, tileSize, tileSize);
            }
            // =======================
            // SPAWN POINT SIMPLE
            // =======================
            else if (val === -2) {

                const x = tx * tileSize;
                const y = ty * tileSize;

                // Fond vert
                ctx.fillStyle = "rgba(46, 204, 113, 0.6)";
                ctx.fillRect(x, y, tileSize, tileSize);

                // Drapeau
                const flagX = x + tileSize / 2;
                const flagY = y + tileSize / 2 + 6;

                ctx.textAlign = "center";
                ctx.font = "20px Arial";
                ctx.shadowColor = "black";
                ctx.shadowBlur = 3;
                ctx.fillStyle = "rgba(255,255,255,0.6)";

                ctx.fillText("üö©", flagX, flagY);
            }


            // =======================
            // ANTI-TRANSITION
            // =======================
            else if (val <= -100) {

                const x = tx * tileSize;
                const y = ty * tileSize;

                // Fond vert
                ctx.fillStyle = "rgba(46, 204, 113, 0.6)";
                ctx.fillRect(x, y, tileSize, tileSize);

                // Drapeau
                const flagX = x + tileSize / 2;
                const flagY = y + tileSize / 2 + 6;

                ctx.textAlign = "center";
                ctx.font = "20px Arial";
                ctx.shadowColor = "black";
                ctx.shadowBlur = 3;
                ctx.fillStyle = "rgba(255,255,255,0.6)";

                ctx.fillText("üö©", flagX, flagY);

                // ID en dessous
                let spawnpointID = (100 + val) * (-1);

                ctx.shadowBlur = 0;
                ctx.font = "bold 11px Arial";

                ctx.fillText(
                    spawnpointID,
                    flagX + 3,
                    flagY + 7
                );
            }



            else if(val > 0) { // Transition
                const x = tx * tileSize;
                const y = ty * tileSize;

                ctx.fillStyle = "rgba(155, 89, 182, 0.7)"; 
                ctx.fillRect(x, y, tileSize, tileSize);
                ctx.fillStyle = "white";
                ctx.font = "bold 14px Segoe UI";
                ctx.textAlign = "center";
                ctx.shadowColor = "black";
                ctx.shadowBlur = 4;

                const targetZoneId = val >> 16;
                const spawnPointId = val & 0xFFFF;

                ctx.fillText(targetZoneId, tx*tileSize + tileSize/2, ty*tileSize + tileSize/2 + 2);
                ctx.shadowBlur = 4;
                ctx.font = "bold 8px Arial";

                ctx.fillText(
                    spawnPointId,
                    x + tileSize / 2,
                    y + tileSize / 2 + 10
                );
            }
        }
        
        // Draw grid over the entire map
        const mapPixelWidth = mapW * tileSize;
        const mapPixelHeight = mapH * tileSize;
        ctx.strokeStyle = "rgba(255,255,255,0.05)";
        for(let x=0; x<=mapPixelWidth; x+=tileSize) {
            ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,mapPixelHeight); ctx.stroke();
        }
        for(let y=0; y<=mapPixelHeight; y+=tileSize) {
            ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(mapPixelWidth,y); ctx.stroke();
        }
        
        // Draw a border around the map boundaries
        ctx.strokeStyle = "#555";
        ctx.lineWidth = 2 / scale; // Keep border width consistent on zoom
        ctx.strokeRect(0, 0, mapPixelWidth, mapPixelHeight);

        // --- Rendu des Entit√©s ---
        entities.forEach(ent => {
            const ex = ent.x * tileSize;
            const ey = ent.y * tileSize;
            
            ctx.fillStyle = ent.type === "NPC" ? "rgba(241, 196, 15, 0.8)" :
                            ent.type === "OBJ" ?  "rgba(52, 152, 219, 0.8)" :
                            "rgba(155, 89, 182, 0.8)"; // IOG
            ctx.globalAlpha = 0.8;

            if (ent.type === 'OBJ') {
                const w = (ent.sizeX || 1) * tileSize;
                const h = (ent.sizeY || 1) * tileSize;
                ctx.fillRect(ex, ey, w, h);
                ctx.strokeStyle = "white";
                ctx.lineWidth = 1;
                ctx.strokeRect(ex, ey, w, h);

                ctx.globalAlpha = 1.0;
                ctx.fillStyle = "white";
                ctx.font = "10px Arial";
                ctx.textAlign = "center";
                ctx.fillText(ent.name, ex + w/2, ey + h/2);
            } else {
                ctx.beginPath();
                ctx.arc(ex + tileSize/2, ey + tileSize/2, tileSize/3, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
                ctx.fillStyle = "white";
                ctx.font = "10px Arial";
                ctx.textAlign = "center";
                ctx.fillText(ent.name, ex + tileSize/2, ey + 10);
            }
        });

        ctx.restore();
    }

    function formatDataWithNewlines(data, width) {
        let result = "";
        for (let i = 0; i < data.length; i++) {
            result += data[i];
            if ((i + 1) % width === 0) result += "\n";
            else result += ",";
        }
        return result.trim();
    }

    function parseEntities(content, maptxt) {

        // 1. Trouver l'offset Y : on descend ligne par ligne jusqu'√† trouver une case qui n'est PAS un mur

        entities = content
            .split('\n')
            .filter(line => line.trim() && !line.startsWith('#'))
            .map(line => {
                const parts = line.split('|');
                const type = parts[0];

                if (type === "IOG") {
                    return {
                        type,
                        name: parts[1],
                        x: parseInt(parts[2]) + offsetX,
                        y: parseInt(parts[3]) + offsetY
                    };
                }

                if (type === "OBJ") {
                    return {
                        type,
                        name: parts[1],
                        sprite: parts[2],
                        x: parseInt(parts[3]) + offsetX,
                        y: parseInt(parts[4]) + offsetY,
                        sizeX: parseInt(parts[5]),
                        sizeY: parseInt(parts[6]),
                        orien: parts[7],
                        diagKey: parts[8]
                    };
                } else {
                    // NPC
                    const orienKeys = ["DOWN", "UP", "LEFT", "RIGHT"];
                    return {
                        type,
                        name: parts[1],
                        sprite: parts[2],
                        x: parseInt(parts[3]) + offsetX,
                        y: parseInt(parts[4]) + offsetY,
                        orien: orienKeys[parseInt(parts[5])] || "DOWN",
                        diagKey: parts[6],
                        actionType: parts[7],
                        destination: parts[8]
                    };
                }
            });
            
        drawMap(); // On force le rafra√Æchissement visuel
    }


    function parseDialogues(content) {
        dialogues = {};
        let currentKey = null;
        
        content.split('\n').forEach(line => {
            line = line.trim();
            if (!line || line.startsWith('#')) return;

            if (line.startsWith('[') && line.endsWith(']')) {
                currentKey = line.substring(1, line.length - 1);
                dialogues[currentKey] = [];
            } else if (currentKey) {
                const parts = line.split('|');
                
                if (parts.length >= 1) {
                    // On utilise .replace() sans le ^ et on ajoute .trim() √† la fin
                    const text = parts[0] ? parts[0].replace(/S:\s*/i, "").trim() : "";
                    const type = parts[1] ? parts[1].replace(/T:\s*/i, "").trim() : "Classic";
                    const action = parts[2] ? parts[2].replace(/A:\s*/i, "").trim() : "NONE";

                    console.log(`Parsed: Text="${text}", Type="${type}", Action="${action}"`);

                    dialogues[currentKey].push({
                        text: text,
                        type: type,
                        action: action
                    });
                }
            }
        });
    }

    function updateInspectorUI(type, move) {
        const isIog = (type === 'IOG'); 
        const isObj = (type === 'OBJ');

        document.getElementById('ent-sprite-group').style.display = isIog ? 'none' : 'flex';
        document.getElementById('ent-orien-group').style.display = isIog ? 'none' : 'flex';
        document.getElementById('dialogues-section').style.display = isIog ? 'none' : 'block';
        document.getElementById('ent-move-group').style.display = (isIog || isObj) ? 'none' : 'flex';
        document.getElementById('ent-dest-group').style.display = (isIog || isObj) ? 'none' : 'flex';
        document.getElementById('ent-size-group').style.display = isObj ? 'flex' : 'none';

        const nameLabel = document.getElementById('ent-name-label');
        if (nameLabel) {
            nameLabel.textContent = isIog ? 'Objet ID:' : 'Nom:';
        }
    } 
    
    function updateInspectorMove(move) {
        const isRandomMove = (move === 'RANDOM' || move === 'NONE');
        document.getElementById('ent-dest-group').style.display = isRandomMove ? 'none' : 'flex';
    }

    function switchEditingKey(val) {
        editingDiagKey = val;
        document.getElementById('editing-diag-key').value = val;
        renderDialogueList();
    }

    // Ajoute une nouvelle ligne de dialogue vide
    function addDialogueRow() {
        const key = editingDiagKey;
        
        if (!key) {
            alert("Indiquez une Diag Key d'abord");
            return;
        }

        if (!dialogues[key]) {
            dialogues[key] = [];
        }

        dialogues[key].push({ 
            text: "Nouveau dialogue", 
            type: "Classic", 
            action: "NONE" 
        });
        
        renderDialogueList();
    }

    // Affiche la liste des dialogues pour la cl√© actuelle
    function renderDialogueList() {
        const list = document.getElementById('dialogue-list');
        list.innerHTML = "";
        const key = editingDiagKey;
        const currentDialogues = dialogues[key] || [];

        currentDialogues.forEach((diag, index) => {
            const row = document.createElement('div');
            row.className = 'diag-row';

            // Parse l'action pour s√©parer la commande des arguments
            const actionParts = diag.action.split(':');
            const actionCmd = actionParts[0] || 'NONE';
            const actionArgs = actionParts.slice(1);

            let actionParamsHTML = '';
            if (actionCmd === 'GIVE_ITEM') {
                const itemName = actionArgs[0] || 'Pokeball';
                const itemQty = actionArgs[1] || '1';
                actionParamsHTML += `
                    <div class="input-group">
                        Item ID: <input type="text" value="${itemName}" oninput="updateActionParams(${index}, this.value, 0)">
                    </div>
                    <div class="input-group">
                        Quantit√©: <input type="number" value="${itemQty}" oninput="updateActionParams(${index}, this.value, 1)" min="1">
                    </div>
                `;
            }
            if (actionCmd === 'CHOICE') {
                actionParamsHTML = '<div style="margin-top:5px; padding-left:10px; border-left: 2px solid #555;">';
                actionArgs.forEach((arg, i) => {
                    let content = arg.replace(/^\{|\}$/g, '');
                    let parts = content.split(',');
                    let cText = parts[0] ? parts[0].trim() : '';
                    let cEvent = parts[1] ? parts[1].trim() : '';
                    actionParamsHTML += `
                        <div class="input-group" style="margin-bottom: 2px;">
                            <input type="text" placeholder="Choix" value="${cText}" style="width: 70px;" oninput="updateChoiceParam(${index}, ${i}, 0, this.value)">
                            <input type="text" placeholder="Event" value="${cEvent}" style="width: 70px;" oninput="updateChoiceParam(${index}, ${i}, 1, this.value)">
                            <button class="btn btn-red" onclick="removeChoice(${index}, ${i})">X</button>
                        </div>`;
                });
                actionParamsHTML += `<button class="btn" style="font-size:0.8em; padding:2px 5px; margin-top:5px;" onclick="addChoice(${index})">+ Choix</button></div>`;
            }
            if (actionCmd === 'MOVE') {

                const moveType = actionArgs[0] || 'SIMPLE';
                const destCoords = actionArgs[1]
                    ? actionArgs[1].replace(/^\{|\}$/g, '')
                    : '';

                actionParamsHTML = `
                    <div class="input-group">
                        Move Type:
                        <select onchange="updateActionParams(${index}, this.value, 0);renderDialogueList()">
                            <option value="RANDOM" ${moveType === 'RANDOM' ? 'selected' : ''}>RANDOM</option>
                            <option value="SIMPLE" ${moveType === 'SIMPLE' ? 'selected' : ''}>SIMPLE</option>
                            <option value="PINGPONG" ${moveType === 'PINGPONG' ? 'selected' : ''}>PINGPONG</option>
                            <option value="LOOP" ${moveType === 'LOOP' ? 'selected' : ''}>LOOP</option>
                        </select>
                    </div>
                `;

                // ‚ûú Destination uniquement si pas RANDOM
                if (moveType !== 'RANDOM') {
                    actionParamsHTML += `
                        <div class="input-group">
                            Destinations (x,y):
                            <input type="text"
                                value="${destCoords}"
                                oninput="updateActionParams(${index}, this.value, 1)"
                                placeholder="Ex: 8,5 ou 1,0;3,2">
                        </div>
                    `;
                }
                else {
                    actionParamsHTML += `
                        <div class="input-group" style="opacity:0.7">
                            Aucun param√®tre requis pour RANDOM.
                        </div>
                    `;
                }
            }
            if (actionCmd === 'CHANGE_DIAG') {  
                const snddiagkey = actionArgs[0] || '';   
                actionParamsHTML = `
                    <div class="input-group">
                        Scd Diag ID: <input type="text" value="${snddiagkey}" oninput="updateActionParams(${index}, this.value, 0)" style="width:80px">
                        <button class="btn" style="padding:2px 5px; margin-left:5px; font-size:0.8em;" onclick="switchEditingKey('${snddiagkey}')">‚û°Ô∏è Edit</button>
                    </div>
                `;
            }



            row.innerHTML = `
                <div class="diag-header">
                    <span>DIALOGUE #${index + 1}</span>
                    <button class="btn btn-red" onclick="removeDiag(${index})">Suppr.</button>
                </div>
                <textarea rows="2" oninput="updateDiag(${index}, 'text', this.value)" placeholder="Texte...">${diag.text}</textarea>
                <div class="input-group">Type: <select onchange="updateDiag(${index}, 'type', this.value)"><option value="Classic" ${diag.type === 'Classic' ? 'selected' : ''}>Classic</option><option value="Object" ${diag.type === 'Object' ? 'selected' : ''}>Object</option></select></div>
                <div class="input-group">Action: <select onchange="updateActionCmd(${index}, this.value)"><option value="NONE" ${actionCmd === 'NONE' ? 'selected' : ''}>NONE</option><option value="GIVE_ITEM" ${actionCmd === 'GIVE_ITEM' ? 'selected' : ''}>GIVE_ITEM</option><option value="HEAL" ${actionCmd === 'HEAL' ? 'selected' : ''}>HEAL</option><option value="CHOICE" ${actionCmd === 'CHOICE' ? 'selected' : ''}>CHOICE</option><option value="MOVE" ${actionCmd === 'MOVE' ? 'selected' : ''}>MOVE</option><option value="CHANGE_DIAG" ${actionCmd === 'CHANGE_DIAG' ? 'selected' : ''}>CHANGE_DIAG</option></select></div>
                <div id="action-params-${index}">${actionParamsHTML}</div>
            `;
            list.appendChild(row);
        });
    }

    // Mise √† jour des donn√©es en temps r√©el
    function updateDiag(index, field, value) {
        const key = editingDiagKey;
        dialogues[key][index][field] = value;
    }

    // Met √† jour la commande d'action et r√©initialise les param√®tres
    function updateActionCmd(index, newCmd) {
        const key = editingDiagKey;
        if (!dialogues[key] || !dialogues[key][index]) return;

        let newAction = newCmd;
        // Si la nouvelle commande a besoin de param√®tres, on les initialise
        if (newCmd === 'GIVE_ITEM') {
            newAction = 'GIVE_ITEM:Pokeball:1';
        } else if (newCmd === 'CHOICE') {
            newAction = 'CHOICE:{Oui,NEXT}:{Non,CLOSE}';
        }
        else if (newCmd === 'MOVE') {
            newAction = 'MOVE:SIMPLE:{8,5}';
        }
        else if (newCmd == 'CHANGE_DIAG') {
            newAction = 'CHANGE_DIAG:' + editingDiagKey +'_2';
        }
        
        dialogues[key][index].action = newAction;
        
        // On redessine la liste pour afficher les nouveaux champs
        renderDialogueList();
    }

    function updateActionParams(index, value, paramIndex) {
        const key = editingDiagKey;
        if (!dialogues[key] || !dialogues[key][index]) return;

        const actionParts = dialogues[key][index].action.split(':');
        const actionCmd = actionParts[0];
        let params = actionParts.slice(1);

        // Si on modifie le type (param 0)
        if (paramIndex === 0 && value === 'RANDOM') {
            // RANDOM n'a pas d'autres param√®tres
            params = ['RANDOM'];
        }
        else {
            while (params.length <= paramIndex) {
                params.push('');
            }
            params[paramIndex] = value;
        }

        dialogues[key][index].action = [actionCmd, ...params].join(':');

        console.log("Action updated:", dialogues[key][index].action);
    }


    function updateChoiceParam(diagIndex, choiceIndex, fieldType, value) {
        const key = editingDiagKey;
        if (!dialogues[key] || !dialogues[key][diagIndex]) return;

        const diag = dialogues[key][diagIndex];
        const parts = diag.action.split(':');
        
        let targetIndex = choiceIndex + 1;
        if (targetIndex >= parts.length) return;

        let content = parts[targetIndex].replace(/^\{|\}$/g, '');
        let subParts = content.split(',');
        if (subParts.length < 2) subParts = [content, ""];

        if (fieldType === 0) subParts[0] = value;
        else subParts[1] = value;

        parts[targetIndex] = `{${subParts[0]},${subParts[1]}}`;
        diag.action = parts.join(':');
    }

    function addChoice(diagIndex) {
        const key = editingDiagKey;
        dialogues[key][diagIndex].action += ":{Choix,NEXT}";
        renderDialogueList();
    }

    function removeChoice(diagIndex, choiceIndex) {
        const key = editingDiagKey;
        let parts = dialogues[key][diagIndex].action.split(':');
        parts.splice(choiceIndex + 1, 1);
        dialogues[key][diagIndex].action = parts.join(':');
        renderDialogueList();
    }

    function removeDiag(index) {
        const key = editingDiagKey;
        dialogues[key].splice(index, 1);
        renderDialogueList();
    }

    function moveDiag(index, direction) {
        const key = editingDiagKey;
        const target = index + direction;
        if (target < 0 || target >= dialogues[key].length) return;
        
        const temp = dialogues[key][index];
        dialogues[key][index] = dialogues[key][target];
        dialogues[key][target] = temp;
        renderDialogueList();
    }

    function exportFiles() {
        // Fusion Map + Wall pour l'export
        const mergedMapData = [];
        for (let i = 0; i < mapData.length; i++) {
            if (wallData[i] >= 1000) {
                 if (wallData[i] >= 2000) {
                      mergedMapData.push(300 + (wallData[i] - 2000));
                 }
                  else {
                    mergedMapData.push(200 + (wallData[i] - 1000));
                  }
            } else if (wallData[i] >= 0) {
                mergedMapData.push(100 + wallData[i]);
            } else {
                mergedMapData.push(mapData[i]);
            }
        }

        const formattedMap = formatDataWithNewlines(mergedMapData, mapW);
        let exportedColl = [];

        playableIndexes.forEach(idx => {
            exportedColl.push(collisionData[idx] ?? 0);
        });

        // m√™me largeur que la zone jouable (int√©rieur)
        const interiorWidth = mapW - offsetX - offsetX2;
        console.log("interiorWidth:", interiorWidth)
        console.log("offsetX2:", offsetX2)
        console.log("offsetX:", offsetX)
        console.log("mapW:", mapW)

        const formattedColl = formatDataWithNewlines(exportedColl, interiorWidth);

        
        // Formatage Entities
        const orienMap = {
            DOWN: 0,
            UP: 1,
            LEFT: 2,
            RIGHT: 3
        };

        const formattedEnt = entities.map(e => {

            const o = orienMap[e.orien] ?? 0;
            const exportX = e.x - offsetX; // On retire l'offset pour le moteur de jeu
            const exportY = e.y - offsetY;
    
            // ... reste de ta logique en utilisant exportX et exportY au lieu de e.x et e.y
            if (e.type === 'IOG') return `${e.type}|${e.name}|${exportX}|${exportY}`;
            if (e.type === 'OBJ') {
                const w = e.sizeX || 1;
                const h = e.sizeY || 1;
                return `${e.type}|${e.name}|${e.sprite}|${exportX}|${exportY}|${w}|${h}|${o}|${e.diagKey ?? ''}`;
            }
            if (e.actionType === 'RANDOM') {
                return `${e.type}|${e.name}|${e.sprite}|${exportX}|${exportY}|${o}|${e.diagKey ?? ''}|${e.actionType}`;
            }
            else if (e.actionType === 'SIMPLE' || e.actionType === 'PINGPONG' || e.actionType === 'LOOP') {
                return `${e.type}|${e.name}|${e.sprite}|${exportX}|${exportY}|${o}|${e.diagKey ?? ''}|${e.actionType}|${e.destination ?? ''}`;
            }
            else {
                return `${e.type}|${e.name}|${e.sprite}|${exportX}|${exportY}|${o}|${e.diagKey ?? ''}`;
            }
        }).join('\n');

        // Formatage Dialogues
        let formattedDiag = "";
        for (let key in dialogues) {
            formattedDiag += `[${key}]\n`;
            dialogues[key].forEach(d => {
                // Format: texte|type|action
                formattedDiag += `S: ${d.text} | T: ${d.type}| A: ${d.action}\n`;
            });
            formattedDiag += `\n`;
        }

        setTimeout(() => download("map.txt", formattedMap), 200);
        setTimeout(() => download("collisionMap.txt", formattedColl), 400);
        setTimeout(() => download("entities.txt", formattedEnt), 600);
        setTimeout(() => download("dialogues.txt", formattedDiag), 800);
    }

    function download(filename, text) {
        let element = document.createElement('a');
        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
        element.setAttribute('download', filename);
        element.style.display = 'none';
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
    }

    initData();
    setMode('draw');
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
</script>

</body>
</html>