@startuml PokemonYunOdd_Class_Diagram

' --- Visual Configuration ---
skinparam classAttributeIconSize 0
skinparam linetype ortho
skinparam nodesep 80
skinparam ranksep 60
skinparam shadowing true
skinparam roundcorner 10

skinparam class {
    BackgroundColor White
    ArrowColor #2C3E50
    BorderColor #2C3E50
    HeaderBackgroundColor #ECF0F1
}

skinparam package {
    BackgroundColor #FDFEFE
    BorderColor #BDC3C7
}

skinparam note {
    BackgroundColor #FEFEFE
    BorderColor #34495E
}

title Detailed Class Diagram - Pokemon Yun & Odd

' ==========================================
' PACKAGE: CORE / ENGINE
' ==========================================
package "Core & Engine" <<Frame>> {

    class Game {
        - m_config : GameConfig
        - m_sceneBuffer : sf::RenderTexture
        - m_window : sf::RenderWindow
        - m_player : Player&
        - m_cameraView : sf::View
        - m_uiView : sf::View
        - m_playerController : PlayerController*
        - m_world : World
        + Game(config : const GameConfig&)
        + run() : void
        - handleEvents() : void
        - update(dt : float) : void
        - render() : void
    }

    struct GameConfig {
        + width : unsigned int
        + height : unsigned int
        + title : std::string
        + playerName : std::string
    }

    class "ResourceManager<Resource>" as ResourceManager << (T,#FFD700) Template, (S,#FF7700) Singleton >> {
        - resources : "std::map<std::string, std::unique_ptr<Resource>>"
        - ResourceManager()
        + {static} getInstance() : ResourceManager<Resource>&
        + get(filepath : const std::string&) : Resource&
        + clear() : void
    }
    note right of ResourceManager
      Manages loading and storage of resources
      like Textures, Fonts, and SoundBuffers.
      Prevents duplicate loading.
    end note
    
    ResourceManager <.down. "TextureManager"
    ResourceManager <.down. "FontManager"
    ResourceManager <.down. "SoundManager"
    
    hide "TextureManager"
    hide "FontManager"
    hide "SoundManager"

    class Controller << (S,#FF7700) Singleton >> {
        - actionMapping : "std::map<std::string, sf::Keyboard::Key>"
        - axisMapping : "std::map<std::string, std::pair<sf::Keyboard::Key, sf::Keyboard::Key>>"
        - pressedActions : "std::set<std::string>"
        - pressedCallbacks : "std::map<std::string, std::vector<ActionCallback>>"
        - releasedCallbacks : "std::map<std::string, std::vector<ActionCallback>>"
        - axisCallbacks : "std::map<std::string, std::vector<AxisCallback>>"
        + {static} getInstance() : Controller&
        + onActionPressed(action: std::string, callback: ActionCallback) : void
        + onActionReleased(action: std::string, callback: ActionCallback) : void
        + onAxisChanged(axis: std::string, callback: AxisCallback) : void
        + handleInput(window: sf::RenderWindow&) : void
    }
    
    class TransitionManager << (S,#FF7700) Singleton >> {
        - m_active : bool
        - m_progress : float
        - m_type : TransitionType
        - m_shader : sf::Shader
        + {static} getInstance() : TransitionManager&
        + init(windowSize: sf::Vector2u) : void
        + start(type: TransitionType, durationIn: float, action: std::function<void()>, durationOut: float) : void
        + update(dt: float) : void
        + render(window: sf::RenderWindow&, sceneTexture: const sf::Texture&) : void
        + isRunning() : bool
    }
    
    enum TransitionType {
        None, Fade, Distortion, Pixelate, RadialWipe, Glitch,
        Blinds, Wind, Kaleido, TVShutdown, Drunk, BlackHole, Ripple
    }
    
    TransitionManager *-- TransitionType
    
    class ScriptManager << (S, #FF7700) Singleton, (F, #00AA00) Facade >> {
        - m_cache : "std::map<std::string, std::vector<DialogueStep>>"
        + {static} getInstance() : ScriptManager&
        + getDialogue(key: const std::string&) : const std::vector<DialogueStep>&
        + loadDialogues(path: const std::string&) : void
        + {static} parseDirections(str: const std::string&) : std::vector<sf::Vector2i>
    }
    note right of ScriptManager
      Facade for loading and parsing game data from text files,
      like dialogues and entity definitions. Caches data.
    end note
}

' ==========================================
' PACKAGE: WORLD & ZONE
' ==========================================
package "World & Zone Management" <<Frame>> {
    class World {
        - m_zone : std::unique_ptr<Zone>
        + World()
        + addZone(zone : std::unique_ptr<Zone>) : void
        + getCurrentZone() : Zone&
        + getCurrentZoneId() : int
        + switchZone(zoneId : int) : void
        + update(dt : float, player : Player&) : void
        + draw(window : sf::RenderWindow&, focus : const WorldEntity&) : void
        + destroyEntity(entity: WorldEntity*) : void
        + init() : void
    }

    class Zone {
        - m_id : int
        - m_width, m_height : unsigned int
        - m_spawnPos : sf::Vector2i
        - m_spawnPoints : "std::map<int, sf::Vector2i>"
        - m_collisionMap : std::vector<int>
        - m_entities : "std::vector<std::unique_ptr<WorldEntity>>"
        - m_tileset : sf::Texture*
        - m_tileMap : TileMap
        + Zone(...)
        + getId() : int
        + isBlocking(x : int, y : int) : bool
        + getEntityAt(x : int, y : int) : WorldEntity*
        + getEntities() : const std::vector<std::unique_ptr<WorldEntity>>&
        + getTileMap() : const TileMap&
        + removeEntity(entity: WorldEntity*) : bool
    }
    
    class ZoneFactory << (F,#00AA00) Factory >> {
        + {static} createZone(zoneId : int) : std::unique_ptr<Zone>
    }
    note bottom of ZoneFactory: Factory Method pattern. Constructs fully initialized Zone objects.

    class MapLoader <<Utility>> {
        + {static} loadFromFile(filepath: const std::string&, width: unsigned int&, height: unsigned int&) : std::vector<int>
    }
    
    class TileMap {
        - m_vertices : std::vector<Vertex3D>
        - m_tileset : const sf::Texture*
        + load(texture: const sf::Texture&, tileSize: sf::Vector2u, tiles: const std::vector<int>&, width: unsigned int, height: unsigned int) : bool
        + getVertices() : const std::vector<Vertex3D>&
        + getTileset() : const sf::Texture*
    }
    
    class CollisionGrid {
      - m_grid: std::vector<int>
      - m_width: unsigned int
      - m_height: unsigned int
      + load(data: const std::vector<int>&, width: unsigned int, height: unsigned int) : void
    }
}

' ==========================================
' PACKAGE: ENTITIES
' ==========================================
package "Entities" <<Frame>> {

    abstract class WorldEntity {
        # m_name : std::string
        # m_logicalPos : sf::Vector2i
        + WorldEntity(name: const std::string&, pos: sf::Vector2i)
        + {abstract} draw(window: sf::RenderWindow&) const : void
        + getPosition() : sf::Vector2i
        + getName() : std::string
        + {abstract} applyState(state: const EntityState&) : void
        + {abstract} getState() const : EntityState
    }

    interface Interactable <<Interface>> {
        + {abstract} interact() : void
    }

    class Character {
        # m_name : std::string
        # m_targetPos : sf::Vector2f
        # m_orientation : int
        # m_sprite : sf::Sprite
        # m_animations : "std::map<std::string, Animation>"
        # m_currentAnim : std::string
        # m_isMoving : bool
        # m_inventory : "std::unique_ptr<Inventory>"
        # m_path : "std::unique_ptr<CharacterPath>"
        + Character(...)
        + moveRequest(direction: sf::Vector2i, zone: Zone&) : void
        + update(dt: float, zone: Zone&) : void
        + getFacingTile() : sf::Vector2i
        + getInventory() : Inventory&
        + setPath(path: std::unique_ptr<CharacterPath>) : void
    }

    class Player << (S,#FF7700) Singleton >> {
        - Player(name: const std::string&)
        + {static} getInstance() : Player&
    }

    class Npc {
        - m_dialogueKey : std::string
        + Npc(...)
        + interact() : void
    }

    class Obj {
        - m_dialogueKey : std::string
        - m_item : "std::optional<Item>"
        - m_sprite : sf::Sprite
        + Obj(...)
        + interact() : void
        + giveItem() : void
    }
    
    class "ItemGround" as Iog {
        - m_sprite : sf::Sprite
        - m_name : std::string
        + Iog(name: std::string, pos: sf::Vector2i)
        + interact() : void
    }
}


' ==========================================
' PACKAGE: ENTITY LOGIC & STATE
' ==========================================
package "Entity Logic & State" <<Frame>> {
    class PlayerController << (S,#FF7700) Singleton >> {
        - m_world : World&
        - m_player : Player&
        - m_inputEnabled : bool
        - {static} s_instance: PlayerController*
        - PlayerController(world: World&, player: Player&)
        + {static} create(world: World&, player: Player&) : void
        + {static} getInstance() : PlayerController*
        + update(zone : Zone&, dt : float) : void
        + enableInput() : void
        + disableInput() : void
    }

    class CharacterPath <<Strategy>> {
        - m_type : PathType
        - m_path : "std::vector<sf::Vector2i>"
        - m_running : bool
        + CharacterPath(type: PathType, ...)
        + addDestination(currentPos: const sf::Vector2i&, dest: const sf::Vector2i&) : void
        + update(dt: float, character: Character&, zone: Zone&) : void
        + start() : void
        + pause() : void
    }
    
    enum PathType {
        RANDOM
        SIMPLE
        LOOP
        PINGPONG
    }
    CharacterPath *-- PathType

    struct EntityState <<State>> {
      + texturePath: std::string
      + type: EntityType
      + position: sf::Vector2i
      + orientation: int
      + dialogKey: std::string
      + inventory: "std::unique_ptr<Inventory>"
      + toJson() : nlohmann::json
      + {static} fromJson(j: const nlohmann::json&) : EntityState
    }
    
    struct ZoneState <<State>> {
      + entities: "std::unordered_map<std::string, EntityState>"
      + toJson() : nlohmann::json
      + {static} fromJson(j: const nlohmann::json&) : ZoneState
    }
    
    class GameInstance << (S, #FF7700) Singleton >> {
        - m_zones: "std::unordered_map<int, ZoneState>"
        - key: std::string
        + {static} getInstance() : GameInstance&
        + getZoneState(zoneId: int) : ZoneState&
        + saveZoneState(zoneId: int, entities: const std::vector<std::unique_ptr<WorldEntity>>&) : void
        + saveToFileEncrypted(filename: const std::string&) : void
        + loadFromFileEncrypted(filename: const std::string&) : void
    }
}


' ==========================================
' PACKAGE: UI & DIALOGUE
' ==========================================
package "UI & Dialogue System" <<Frame>> {
    class DialogManager << (S,#FF7700) Singleton >> {
        - m_msgBox : GameDialog*
        - m_currentSpeaker : WorldEntity*
        - m_queue : "std::queue<DialogueStep>"
        - m_active : bool
        - m_actionAfter: std::function<void()>
        + {static} getInstance() : DialogManager&
        + init(msgBox : GameDialog*) : void
        + startDialogue(steps : const std::vector<DialogueStep>&, speaker: WorldEntity*, ...) : void
        + next() : void
        + isActive() : bool
        + draw(window: sf::RenderWindow&) : void
    }

    class GameDialog {
        # m_boxSprite : sf::Sprite
        # m_segments : "std::vector<TextSegment>"
        # m_visible : bool
        + GameDialog()
        + setBoxType(type : BoxType) : void
        + setText(rawText : const std::string&) : void
        + show() : void
        + hide() : void
        + {virtual} draw(window: sf::RenderWindow&) : void
    }
    
    enum BoxType {
        Classic
        Object
    }
    GameDialog *-- BoxType
    
    class GameChoiceBox << (S,#FF7700) Singleton >> {
        - m_choices : "std::map<std::string, std::string>"
        - m_currentIndex : int
        + {static} getInstance() : GameChoiceBox&
        + init(choices: std::map<std::string, std::string>) : void
        + draw(window: sf::RenderWindow&) : void
    }
    
    struct DialogueStep {
        + text : std::string
        + type : BoxType
        + action : std::function<void()>
    }
}

' ==========================================
' PACKAGE: ITEMS & INVENTORY
' ==========================================
package "Items & Inventory" <<Frame>> {
    class Item {
        - m_name : std::string
        - m_description : std::string
        - m_pocket : ItemPocket
        - m_consumable : bool
        + Item(name: std::string, pocket: ItemPocket, ...)
        + getName() : const std::string&
        + getPocket() : ItemPocket
    }

    class Inventory {
        - m_pockets : "std::map<ItemPocket, Pocket>"
        + addItem(item: const Item&, quantity: int) : void
        + removeItem(item: const Item&, quantity: int) : bool
        + getQuantity(item: const Item&) : int
        + toJson() : nlohmann::json
        + {static} fromJson(j: const nlohmann::json&) : Inventory
    }
    
    enum ItemPocket {
        Items
        Balls
        KeyItems
        TMsHMs
        Berries
    }
    Item *-- ItemPocket
    Inventory o-- ItemPocket
}

' ==========================================
' PACKAGE: EVENTS
' ==========================================
package "Event System" <<Frame>> {
    class "Event<Args...>" as Event << (T,#FFD700) Template, (O,#58D68D) Observer >> {
        - listeners : "std::vector<Listener>"
        + subscribe(listener: Listener) : void
        + notify(args: Args...) : void
    }
    
    struct GameEvents {
        + {static} OnPlayerMove : "Event<int, int>"
        + {static} OnDialogueTrigger : "Event<std::string>"
        + {static} OnEntityDestroyed : "Event<WorldEntity*>"
    }
    note left of GameEvents : Central hub for all game events.
}

' ==========================================
' RELATIONSHIPS
' ==========================================

' --- Inheritance ---
WorldEntity <|-- Character
WorldEntity <|-- Obj
WorldEntity <|-- Iog
Character <|-- Player
Character <|-- Npc
Interactable <|.. Npc
Interactable <|.. Obj
Interactable <|.. Iog
GameDialog <|-- GameChoiceBox

' --- Composition / Aggregation ---
Game *-- World
Game *-- GameConfig
Game o-- Player
Game *-- PlayerController

World "1" *-- "1" Zone : owns >

Zone "1" *-- "*" WorldEntity : owns >
Zone *-- TileMap
Zone o-- sf::Texture

Character "1" *-- "1" Inventory : owns >
Character "1" *-- "0..1" CharacterPath : owns >
Character o-- Animation

Inventory "1" o-- "*" Item : contains >

DialogManager o-- GameDialog
DialogManager *-- DialogueStep

GameInstance "1" *-- "*" ZoneState : manages state >
ZoneState "1" *-- "*" EntityState : contains state >

' --- Dependencies / Usage ---
Game ..> TransitionManager : uses
Game ..> DialogManager : uses
Game ..> PlayerController : uses

PlayerController ..> Controller : uses
PlayerController ..> World : controls >
PlayerController ..> Player : controls >

World ..> ZoneFactory : uses to create
ZoneFactory ..> MapLoader : uses
ZoneFactory ..> ResourceManager : uses
ZoneFactory ..> ScriptManager : uses
ZoneFactory ..> GameInstance : uses
ZoneFactory ..> Npc : creates
ZoneFactory ..> Obj : creates
ZoneFactory ..> Iog : creates

Npc ..> DialogManager : triggers
Obj ..> DialogManager : triggers
Iog ..> DialogManager : triggers

ScriptManager ..> DialogManager : provides data
ScriptManager ..> Player : gives item
ScriptManager ..> GameChoiceBox : creates
ScriptManager ..> CharacterPath : configures

Controller ..> Event : triggers (indirectly)
PlayerController ..> Event : triggers (indirectly)

@enduml